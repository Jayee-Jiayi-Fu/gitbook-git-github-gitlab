{"./":{"url":"./","title":"Introduction","keywords":"","body":"Git - GitHub - GitLab 极客时间课程《玩转三剑客》学习的笔记 Git 01 安装 Git 及常规配置 02 创建仓库及基本工作命令 03 文件的重命名和删除 04 创建、切换、删除分支 05 三个对象 commit、tree 和 blob 06 分离头指针下的注意事项 07 怎么比较文件的差异？ 08 怎么修改和合并 commit？ 09 如何恢复工作区、暂存区文件？ 10 开发中临时加塞了紧急任务怎么处理？ 11 一些常用终端命令 GitHub 01 如何实现仓库备份？ 02 配置 SSH 秘钥及同步仓库 03 多人合作开发遇到的问题 04 团队开发中一些强烈禁止的操作 05 怎么快速搜索感兴趣的项目？ 06 选择工作流和集成策略 07 给项目增加详细的指导文档 GitLab By Jayee            modified at 2020-02-10 13:21:37 "},"Git/01安装Git及常规配置.html":{"url":"Git/01安装Git及常规配置.html","title":"01安装Git及常规配置","keywords":"","body":"01. 安装Git及最小配置 git的安装请参考这份文档)，不在赘述。 查看当前Git版本： git --version Git安装完成后，必须配置用户名和邮箱 ： git config user.name 'your_name' git config user.email 'your_email' 配置有三个作用域，不同作用域优先级不同（local>global>system）： #--local 只对当前仓库有效（默认作用域） git config --local user.name 'your_name' #--global 对当前用户所有仓库有效 git config --global user.name 'your_name' #--system 对系统所有登录用户有效 git config --global user.name 'your_name' 显示config配置列表： git config --local --list 指定显示某个config的值： git config --local user.name By Jayee            modified at 2020-02-10 13:21:37 "},"Git/02创建仓库及基本工作命令.html":{"url":"Git/02创建仓库及基本工作命令.html","title":"02创建仓库及基本工作命令","keywords":"","body":"02. 创建仓库及基本工作命令 创建 Git 仓库 把已有项目纳入 Git 管理 cd your_project git init 新建项目直接用 Git 管理 cd some_where git init your_project #在当前路径下创建与项目同名的文件夹 cd your_project 基本工作命令 添加变更到暂存区 在工作区对工程作出变更后，可先添加到暂存区交给 Git 管理。正如其名，暂存区用于暂时存放变更，而不是作为一次正式提交，我们仍能在工作区作出修改。若修改结果比暂存区的更好，即可用当前状态覆盖暂存区。反之，可取回暂存区的状态重新修改： git add file.md 对 Git 已经跟踪的多个文件，可一次性添加到暂存区： git add -u 无论文件是否已跟踪，都一次性添加到暂存区： git add . 提交变更到历史版本 当认为暂存区的变更可作为一次完整修改后，需要进行 commit 提交，并说明理由。Git 会为这次提交创建一个 commit 对象，它拥有唯一 ID、日期、作者等信息，最重要的是它保存了本次提交时的工程快照。Git 视其为一次提交历史，如有需要，可令工程回退到这次提交时的状态。提交命令如下： git commit -m\"message\" add和commit命令可以合并使用，但必须是针对已跟踪文件。若文件尚未跟踪，必须先add进暂存区。 git commit -am\"message\" 整个过程如下图所示： 查看当前文件状态 任何时候都可以查看，当前哪些文件做出了修改，哪些文件未被追踪等信息： git status 查看版本演变历史 常规查看当前分支的历史： git log 查看所有分支的历史： git log --all 以更简洁的方式显示： git log --oneline 显示最近的几条历史，当设置了--all参数时，即对所有分支而言最近的几次历史： git log -n3 显示历史记录的同时画出分支演化图： git log --graph 通过图形工具查看版本历史： gitk 查看操作记录 查看当前分支上的操作记录： git reflog By Jayee            modified at 2020-02-10 13:21:37 "},"Git/03文件的重命名和删除.html":{"url":"Git/03文件的重命名和删除.html","title":"03文件的重命名和删除","keywords":"","body":"03. 文件的删除和重命名 文件删除 如需删除某个已跟踪文件，可直接在文件路径中手动删除，再把删除操作添加到暂存区。也可直接使用rm命令，一步到位： git rm file.md 文件重命名 把文件名从\"file\"更改为\"newFile\"，同时把变更添加到暂存区： git mv file.md newFile.md By Jayee            modified at 2020-02-10 13:21:37 "},"Git/04创建、切换、删除分支.html":{"url":"Git/04创建、切换、删除分支.html","title":"04创建、切换、删除分支","keywords":"","body":"04. 创建、切换、删除分支 新建分支 基于某次commit创建新分支： git -b new_branch 60b1b65 或基于已有分支创建新分支： git -b new_branch master 分支命名应该具有其含义，例如为了什么功能做开发或者修复某个bug 查看已有分支 # 查看本地所有分支 git branch -v # 查看本地和远端的所有分支 git branch -av 切换分支 git checkout new_branch 创建和切换命令可以合并，这样将在新建分支后直接切换： git checkout -b new_branch master 删除分支 指定需要删除的分支，如果该分支已无待合并内容，用-d参数删除： git branch -d new_branch 若提示The branch 'new_branch' is not fully merged，分支中仍有未合并内容，但仍希望删除分支，就可用-D参数： git branch -D ne By Jayee            modified at 2020-02-10 13:21:37 "},"Git/05三个对象commit、tree和blob.html":{"url":"Git/05三个对象commit、tree和blob.html","title":"05三个对象commit、tree和blob","keywords":"","body":"05. 三个对象:commit、tree 和 blob 探秘隐藏的.git 文件 .git 中存放了 Git 进行版本控制所需的文件。其中最重要的有几个：HEAD、config、refs/、objects/。 HEAD文件中存放着一个引用，指向当前正在使用的分支： #HEAD>> ref:refs/heads/master config文件中存放当前项目的配置信息。config命令的--local作用域修改的就是这里的数据： #config>> ... [user] name = your_name email = your_email refs文件夹中存放了与 heads(分支)、tags（标签）等相关信息。上面 HEAD 文件的引用就是指向此处： #refs/>> heads/ |-master |-new_branch tags/ |-v1.0.0 heads/master中存放的是一个指针： ce1ed38a...(略) 我们通过下面命令查看该指针的类型： git cat-file -t ce1ed38a 得到输出如下。也就是说，这个 HEAD 指针指向一个 commit 对象： commit 我们再通过下面命令查看这个 commit 对象的内容： git cat-file -p ce1ed38a 得到输出如下。commit 中可以看到提交的相关信息，而且它包含一个tree对象： tree ce1ed38a...(略) author author_name ... committer committer_name ... message of this commit 同理，tags/v1.0.1中也是一个指针，指向的对象是 tag 类型。tag 对象内容是一个 commit 对象。 objects/中的两字符目录存放了 Git 所跟踪的对象。Git 会进行自我梳理操作，当松散文件较多时就进行打包并存放到pack/目录。 进入其中一个两字符目录，里面存放的是以哈希值命名的文件。外层目录的两个字符+内层文件名的哈希值组成一个完整的指针。例如f3里存放了一个名为7d0f449...(略)的文件，就组成完整指针f37d0f449...(略)。 尝试查看这个指针的类型是tree，内容包含了一个blob类型的对象，指向某个文件： 100644 blob b72e61...(略) style.css 你可能已经察觉出来了，可以仍未 tree 对象表示目录，blob 对象表示文件。commit 对象包含的 tree 对象，可视为一个顶级快照目录。 tree、commit 和 blob 的关系 假设当前有如下目录： readme.md index.html styles/ |-style.css images/ |-git-logo.png 在添加完 style.css 文件后，进行历史提交，就可获得一指针。通过这个指针，我们查到它是一个 commit 对象。除了父历史，作者、提交者等信息外，每个 commit 都会包含一个 tree。这个 tree 可视为该次提交的项目快照。 由 tree 的指针再查找其对象，发现包含里面还包含了两个子 tree 和两个 blob 文件，分别指向了 images、styles 目录和 readme、index.html 文件。子树对象又包含各自的 blob 文件。打开 blob 文件，正是上面给出的工程文件。 可见，在 Git 的每次历史提交中，文件目录 以 tree 对象保存，文件则以 blob 对象保存在 tree 中，所有的 tree 和 blob 又保存在一个顶级 tree 中，该顶级 tree 则属于一次历史 commit。 小练习：数一数 tree 的个数 新建的 Git 仓库，有且仅有 1 给 commit，仅仅包含/doc/readme，请问含有多少给 tree，多少给 blob？ 一个 commit 中含有一个顶级 tree，包含当前快照。快照中 doc 目录保存在一个 tree 里，一个 readme 就是一个 blob。所以一共是两个 tree，和一给 blob。 整个操作过程如果对照着 objects/目录查看，就可知道，在add操作时，Git 先创建了文件 blob 对象。在 commit 后，再创建 commit 对象，顶级 tree 对象和doc/目录 tree 对象。你可尝试运行下面命令，看看objects/中是否共有这四个对象。 find ./git/objects -type f By Jayee            modified at 2020-02-10 13:21:37 "},"Git/06分离头指针下的注意事项.html":{"url":"Git/06分离头指针下的注意事项.html","title":"06分离头指针下的注意事项","keywords":"","body":"06. 分离头指针下的注意事项 什么是分离头指针？ 假设直接对某个更早的commit历史执行checkout命令，Git会给出以下提示： Note: checking out '415ed6....(commit指针，略)' You are in 'detached HEAD' state... HEAD is now at 415ed6 message of commit 现在我们就处于分离头指针状态。本质上就是指工作在没有分支的状态。 我们仍然可以对文件进行修改和提交。当前的HEAD不是指向某个分支，而是最新的commit。在下次执行checkout切换分支操作时，在此状态下所创建的所有commit都会被丢弃，然后被Git当作垃圾回收掉。当然我们也可以通过创建新分支来保留这些commit。 分离头指针适用于这样的场景：对项目做尝试性变更，若随后发现有更好方案，就可直接执行checkout指令，快速恢复到起始状态，而无需执行删除变更等操作。若对修改满意，就保 留到分支上。 分支和HEAD 对HEAD而言，HEAD可以指向某个具体的commit，没有和任何分支挂钩。 但是每次创建并切换新分支后，HEAD却会随之指向新分支。在.git/HEAD文件中能够找到当前HEAD所指向分支的引用，随之找到存放分支的文件.git/refs/heads/new_branch。分支文件里是某个commit的指针。 总而言之，HEAD都是落脚到某个具体的commit的。 By Jayee            modified at 2020-02-10 13:21:37 "},"Git/07怎么比较文件的差异？.html":{"url":"Git/07怎么比较文件的差异？.html","title":"07怎么比较文件的差异？","keywords":"","body":"07. 怎么比较文件的差异？ 若想比较当前工作区与暂存区的差异，不需带参数： git diff 因为HEAD亦指代某个commit，HEAD^1（或HEAD^）指代HEAD的父亲，HEAD^1^1(或HEAD^^，或HEAD~2)指代父亲的父亲，所以也可这样比较： git diff HEAD HEAD~2 若想比较暂存区和HEAD差异，必须带上--cached参数： git diff --cached 若想比较不同commit间的差异： #可以直接比较两个分支名，因为分支会指向某个commit git diff branch1 branch2 #也可以比较两个commit git diff 5fe57fc7 49f31c2d 若想指定需要比较的某几个文件，上述所有命令都可以在最后加上--指定： git diff -- file1.md file2.md By Jayee            modified at 2020-02-10 13:21:37 "},"Git/08怎么修改和合并commit？.html":{"url":"Git/08怎么修改和合并commit？.html","title":"08怎么修改和合并commit？","keywords":"","body":"08. 怎么修改、合并、删除 commit？ 修改 commit 修改最近一次 commit 的 message git commit --amend 此时若出现编辑器错误提示，可指定使用 vim 编辑器： git config --global core.editor vim 在打开的 commit 对象文件中，可看到该 commit 的相关信息，并可直接修改 message 内容。修改完成后，Git 会生成一个新的 commit 来替代原来的 commit，所以你会看到 commit 的指针号已改变。 你也可以直接在命令行中快捷修改： git commit --amend -m \"new message\" 修改最近一次 commit 的快照 若希望修改最近一次 commit 的文件内容，但又不想留下多一个 commit 记录，可以在变更文件并add进暂存区后执行下面命令: git commit --amend --no-edit 它会新建一个 commit 替代原来的，并且拥有一样的 message，历史记录上的 commit 数不变。 修改老旧 commit 的 message 修改任何非最近的 commit，都需要变基操作。找到需要修改的 commit，基于它的父 commit 执行指令： git rebase -i 11fbaa2 执行上面指令后，Git 将打开策略文件如下。按照策略，把需要修改的 commit 前的pick改为r，保存退出。 然后 Git 会打开修改了策略的 commit 对象文件，在这个文件中修改 message 为“change readme content and message”，保存退出。操作完成后终端给出成功提示信息如下： [detached HEAD 6ff26b9] change readme content and message Date: Tue Feb 4 08:58:35 2020 +0800 1 file changed, 1 insertion(+), 1 deletion(-) Successfully rebased and updated refs/heads/master. 上面信息表示，Git 会先分离头指针，作出修改后，从修改位置起往后的全部记录都会用新的 commit 代替。原来的 HEAD 指针也会随之指向新的 commit。 之所以会产生新的 commit，是因为，基于某个父 commit 的子 commit 对象，它的 message 改变了，所以变成了新的 commit，拥有新的指针 ID。它后面的 commit，则是由于 commit 对象的 parent 属性中，保存的前一个 commitID 改变了，所以生成新的 commit。就像多米诺牌，一直延续到最近的历史也被新 commit 替换后才停下。 使用reflog命令可以看到这个过程： 变基操作适用于 commit 还没贡献享到团队的集成分支上，仅在个人工作区修改的情况。如果 commit 已贡献出去，就不应该随意地进行变基操作，否则会对团队成员造成很大影响。 合并 commit 把连续多个 commit 整理成一个 现在有如下历史记录： 4e76288 (HEAD -> master) add index 3c5a670 change readme again 9d32c55 change readme 2e98b74 add readme 765d707 rm readme 6ff26b9 change readme content and message 11fbaa2 add readme 现在要把除首尾两个 commit 外的所有 commit 合并。合并 commit 也是一个变基操作，所以找到需要修改的最早 commit 的父 commit，执行命令： git rebase -i 11fbaa2 随后在打开的策略文件中改pick为squash(或简写s)，表示将对应 commit 合并到前一个 commit，保存退出。 Git 会创建一个新的 commit，保存所有合并 commit 的内容，你可以在该 commit 对象文件中编辑它的 message： 保存退出后，在查看历史，发现分支已合并。当然，除父 commit 外，所有往后的 commit 都是新的。 把不连续的多个 commit 整理成一个 现有目录如下： 3030aca (HEAD -> master) add index 988b256 a complete readme...(略) 11fbaa2 add readme 现在需要把首尾两个 commit 合并成一个，也是执行变基操作： git rebase -i 11fbaa2 但由于基底已是最早的 commit，在策略文件中不会显示，所以需要手动添加 commit 记录，再把需要合并的 commit 移动到它下面，改策略为s。保存退出： 由于没有基底，即新 commit 的前一个初始 commit 为空，导致了一个冲突。git status给出提示信息如下： 按照提示执行命令以解决冲突: git rebase --continue 然后就可以在新 commit 对象文件中编辑 message 信息。最用运行结束后，看到的提交历史是这样子的： 删除 commit 删除最近几个 commit，等同于回到之前某次提交，并清空工作区和暂存区： git reset --hard f09122c By Jayee            modified at 2020-02-10 13:21:37 "},"Git/09如何恢复工作区、暂存区文件？.html":{"url":"Git/09如何恢复工作区、暂存区文件？.html","title":"09如何恢复工作区、暂存区文件？","keywords":"","body":"09. 如何恢复工作区、暂存区文件？ 恢复工作区文件 若工作区的修改不想保留，希望恢复到上次add到暂存区的文件状态，可用以下命令（--表示后面跟着的是文件）： git checkout -- file.md 恢复暂存区文件 若暂存区的所有修改都不想保留，希望恢复到与 HEAD 的一样： git reset HEAD 若只想取消暂存区部分文件的更改，恢复到与 HEAD 的一样，需要指定操作文件： git reset HEAD -- file.md file2.md 若想恢复到之前某个 commit 的状态，即删除最近几次提交 ，同时工作区和暂存区内容都恢复到与该 commit 时一样（删除的文件会丢失，必须谨慎操作）： git reset --hard e2f2c89cb 若想恢复到之前某个 commit 的状态，而相对该 commit 的其他现有变更都放入暂存区，等待被提交： git reset --soft e2f2c89cb 我们知道，只要重置到某个历史 commit，就能恢复到当时的开发环境。但某些操作例如变基，在log命令下是看不到原来的 commit 的，又该怎么办呢？可以用git reflog命令查看操作记录： 比起log命令仅仅查看当前存在的 commit，reflog命令可以查看项目创建至今的所有 commit。选择某个 commit 哈希值，或者相对当前 HEAD 指针的位移来恢复 commit： git reset HEAD@{11} 记忆：恢复工作区用checkout，恢复暂存区用reset By Jayee            modified at 2020-02-10 13:21:37 "},"Git/10开发中临时加塞了紧急任务怎么处理？.html":{"url":"Git/10开发中临时加塞了紧急任务怎么处理？.html","title":"10开发中临时加塞了紧急任务怎么处理？","keywords":"","body":"10.开发中临时加塞了紧急任务怎么处理？ 若工作区和暂存区都已存在变更，但需处理其他紧急任务，不妨先把当前环境缓存起来： git stash 该操作后，工作区和暂存区都会恢复成干净状态，以便着手处理紧急任务。而旧环境则会在一个堆栈中被缓存起来，终端提示当前缓存为stash{0}。若多次执行该命令，压入栈中的环境会越来越多，大括号中的数字也会随之递增。 若想查看所有的缓存环境： git stash list 若想取出缓存的环境有两种方法： apply参数是获取栈顶环境，恢复工作区和暂存区内容，同时保留该记录。即stash{0}仍存在，可供反复调用： git stash apply pop参数则是直接弹出环境，恢复工作区和暂存区内容，记录也会被删除： git stash pop By Jayee            modified at 2020-02-10 13:21:37 "},"Git/11一些常用终端命令.html":{"url":"Git/11一些常用终端命令.html","title":"11一些常用终端命令","keywords":"","body":"11. 一些常用终端命令： # 新建文件夹 mkdir dir # 删除文件夹 rm -r dir # 新建文件，并写入“hello world” echo \"hello world\" > file.text # 使用vi编辑器打开文件,若文件不存在，就先创建后打开 vi file.text # 直接在终端输出文件内容 cat file.text # 删除文件 rm file.text #打开某个应用 start typora ./dir/path # 查找某个目录下的某个类型文件 find ./dir -type f By Jayee            modified at 2020-02-10 13:21:37 "},"GitHub/01如何实现仓库备份？.html":{"url":"GitHub/01如何实现仓库备份？.html","title":"01如何实现仓库备份？","keywords":"","body":"01.如何实现仓库备份？ 常用传输协议 备份就需要传输，传输就离不开传输协议。常用的传输协议如下: 常用协议 语法格式 说明 本地协议（1） /path/to/repo.git 哑协议 本地协议（2） file:///path/to/repo.git 智能协议 http/https 协议 http://git-server.com:port/path.to/repo.githttps://git-server.com:port/path.to/repo.git 智能协议 ssh 协议 user@git-server.com:path/to/repo.git 智能协议 前两个是本地协议，顾名思义在本地使用的。而日常的团队开发通常在远端会有一个公共的托管平台，如 GitHub、GitLab，使用的则是后两个协议。 http/https 协议需要用户名和密码，ssh 协议需要公私钥配合。 哑协议的传输进度不可见。智能协议传输可见，且比哑协议传输速度快。 平时接触到的多是智能协议，ssh 协议则是最常用的智能协议。 备份特点 Git 仓库支持多点备份。本地仓库向其备份点push贡献代码，fetch拉取更新。 仓库备份/共享 文件通常会备份到一个裸仓库中，里面只有.git目录，没有其它普通仓库那样的文件结构可供浏览和修改。但保存了所有的历史记录。一般来说，一个裸库往往被创建用于作为大家一起工作的共享库。 所有裸仓库无论是存放在本地还是服务器端，对它的克隆仓库而言都是远端仓库。而 remote 只支持智能传输，所以与共享仓库之间的数据传输方式必须是智能传输。 创建备份裸仓库有两种形式： 直接新建共享仓库： git init --bare /path/to/pro.git 基于已有仓库新建共享仓库： git clone --bare /path/to/pro /path/to/pro.git 构建了共享仓库之后，就要与本地仓库关联起来，这又有两种情况： 直接克隆 克隆仓库中除了和共享仓库一样的.git目录外，还拥有项目开发所需的资源文件，并默认创建了名为origin的远程分支关联到共享仓库。 git clone file:///path/to/pro.git 手动添加关联 如果共享仓库是基于本地仓库创建的，就需要手动为本地仓库创建指向共享仓库的远程分支： git remote add origin file:///path/to/pro.git 成功建立关联后，就可以向共享仓库执行push提交或pull / fetch同步。 By Jayee            modified at 2020-02-10 13:21:37 "},"GitHub/02配置SSH秘钥及同步仓库.html":{"url":"GitHub/02配置SSH秘钥及同步仓库.html","title":"02配置SSH秘钥及同步仓库","keywords":"","body":"02. 配置SSH秘钥及同步仓库 账号注册与SSH秘钥配置 到GitHub官网注册账号后，相当于拥有了一个远端存储服务器来读写数据。那么就得先设置好传输协议。常用的是SSH协议。官方文档里给出了详细的配置教程。 这里列出关键步骤： 检查现有 SSH 密钥 # 查看id_rsa.pub公钥文件是否已存在 ls ~/.ssh -al 没有则生成新SSH秘钥 ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" 将SSH秘钥添加到ssh-agant # 在后台启动 ssh-agent eval $(ssh-agent -s) # 将 SSH 私钥添加到 ssh-agent ssh-add ~/.ssh/id_rsa 将 SSH 密钥复制到剪贴板 clip 个人GitHub主页> Settings（设置）> SSH and GPG keys > New SSH key 或Add SSH key: 在 \"Title\"（标题）字段中，为新密钥添加描述性标签，将密钥粘贴到 \"Key\"（密钥）字段。 本地仓库同步到Git 添加远端仓库 git remote add local_name_for_remote_repo remote_repo_SSH_address 拉取远端数据 只拉取远端数据，不与本地分支合并： git fetch local_name_for_remote_repo 先拉取远端数据，再与本地分支合并： git pull local_name_for_remote_repo branch 若出现关于“fast-forwards ”错误提示，表示本地该分支不是基于远端的同名分支做变更，远端不接受push操作。有两种方式解决：一是rebase，二是merge。 执行merge操作时，若出现“refusing to merge unrelated histories”错误提示，表示两个待合并commit并不基于相同的历史。执行下面命令，继续合并，生成新commit： # checkout到待合并分支后 git merge --allow-unrelated-histories ocal_name_for_remote_repo/branch 推送数据到远端 推送指定分支到某个远端仓库： git push local_name_for_remote_repo branch 推送本地所有分支到远端仓库： git push --all local_name_for_remote_repo By Jayee            modified at 2020-02-10 13:21:37 "},"GitHub/03多人合作开发遇到的问题.html":{"url":"GitHub/03多人合作开发遇到的问题.html","title":"03多人合作开发遇到的问题","keywords":"","body":"03. 多人合作开发遇到的问题 远端开发前提 若需对远端某个分支进行修改，有两点需要确保无误： 一是建立起与远端仓库的联系： git add remote name_for_remote_repo remote_repo_address 如果已经建立联系，但远端的某个分支本地还没有： git fetch 二是基于远端分支创建本地同名分支(也可以不同名，但容易混乱)： git checkout -b branch_name name_for_remote_repo/branch_name 此时需要推送本地变更时，可以直接： git push 多人修改了不同文件或同文件不同区域如何处理？ 在本次提交前，他人已向远端仓库做了变更。首先就要拉取最新代码： git fetch name_for_remote_repo 然后进行合并操作： git merge name_for_remote_repo/branch_name 如需放弃合并操作： git merge --abort 多人修改了同文件的同一区域如何处理？ 步骤与上一种情况相同，先拉取远端代码到本地合并。但在合并代码时，由于远端和本地修改了相同区域，所以出现了冲突提示 “Merge conflect in file.md”。 使用编辑器打开冲突文件: vi file.md 查看冲突提示，\"====\"符号上下分别是本地和远端的修改差异，手动修改内容后保存退出（Git 给出的提示信息行需要删除）： 解决冲突后，由于有了新的变更，所以要重新添加到暂存区，然后提交： git commit -am \"resolved conflect message\" 多人分别变更了文件名和文件内容如何处理？ 若提交文件时发现远端仓库的文件名已被其他人修改了，可以直接使用 pull 拉取最新变更，并与本地合并，Git 能够自动识别到对应文件并更改文件名。 git pull 多人把同一文件改成了不同的文件名如何处理？ 现有两个人先后对名为 index 的文件做更名操作，分别改为 index1 和 index2。index2.htm 顺利更名，另一个人在更名为 index1.htm 时发现，Git 无法智能处理，此时查看 status 状态如下： 针对每一项操作如下： git rm index.htm git rm index2.htm git commit -m \"finish merging message\" By Jayee            modified at 2020-02-10 13:21:37 "},"GitHub/04团队开发中一些强烈禁止的操作.html":{"url":"GitHub/04团队开发中一些强烈禁止的操作.html","title":"04团队开发中一些强烈禁止的操作","keywords":"","body":"04. 团队开发中一些强烈禁止的操作 禁止向集成分支执行push -f 若当前切换到了更早期的commit上进行开发，并执行了强制提交，该commit往后的所有提交都会丢失。 git push -f git push --force 禁止向集成分支执行变更历史的操作 如果团队中某个成员修改了集成分支的历史，但其他人则是基于原始历史做修改的，其他人提交时会发现所基于的历史不见了。所以永远应该基于最新历史的往上进行代码修改，而不是对集成分支的历史树进行变更。 By Jayee            modified at 2020-02-10 13:21:37 "},"GitHub/05怎么快速搜索感兴趣的项目？.html":{"url":"GitHub/05怎么快速搜索感兴趣的项目？.html","title":"05怎么快速搜索感兴趣的项目？","keywords":"","body":"05. 怎么快速搜索感兴趣的项目？ 默认在项目名及项目描述中搜索关键字：keyword 指定在某个文件中搜索关键字：keyword in:readme 指定stars数：keyword stars:>1000 指定搜索某个文件：filename:gitlab-cli.yml 指定搜索某包含某些内容的文件：‘after_script:' + 'stage:deploy' filename:gitlab-cli.yml （GitHub中，搜索代码及搜索仓库不能同时相结合） By Jayee            modified at 2020-02-10 13:21:37 "},"GitHub/06选择工作流和集成策略.html":{"url":"GitHub/06选择工作流和集成策略.html","title":"06选择工作流和集成策略","keywords":"","body":"06. 选择工作流和集成策略 需要考虑的因素 团队人员的组成 研发设计能力 输出产品的特征 项目难以程度 不同工作流的优缺点 主干开发 适用于： 开发团队系统设计和开发能力强。 有一套有效的特性切换的实施机制，保证上线后无需修改代码就能够修改系统行为。 需要快速迭代，想获得 CI/CD 所有好处。 组件开发的团队，成员能力强，沟通顺畅。 用户升级组件成本低。 缺点： 优劣代码无法很好的区分就被融合，给稳定上线造成困难 并不适合功能复杂的的项目开发 Git Flow 适用于： 不具备主干开发能力 有预备的发布周期 需要执行严格的发布流程 开发时间长，对产品质量要求比较高 缺点： 流程过于复杂，某些分支需要来回切换，某些分支使用频率很低 GitHub Flow 适用于： 不具备主干开发能力 随时集成随时发布：分支集成时经过代码评审和自动化测试，就可以立即发布的应用 GitLab Flow（带生产分支） 适用于： 不具备主干开发能力 无法控制准确的发布时间，但又要求不停地集成 GitLab Flow (带环境分支) 适用于： 不具备主干开发能力 需要逐个通过测试环境的检验才能发布 GitLab Flow（带发布分支） 适用于： 不具备主干开发能力 需要对外发布和维护不同版本 挑选合适的分支集成策略 有分支图如下所示： 现需把特性分支Beijing集成到主干分支 master 上。GitHub 提供了三种不同的集成方式： create a merge commit 策略 只要不产生合并冲突，就自动在集成分支上产生一个合并 commit squash and merge 策略 特性分支不受影响 从集成分支和特性分支最近的公共祖先（15 坐标）开始，把特性分支的变更集运用到集成分支的最新提交（21 坐标）处，生成一个新的 commit（24 坐标） 形成线性的集成分支树 但如果特性分支上的 commit 彼此相对独立的，这样的合并集成不利于跟踪 rebase and merge 策略 特性分支不受影响 特性分支上的 commit 被一个个地合并到集成分支上 形成线性的集成分支树 多分支集成 By Jayee            modified at 2020-02-10 13:21:37 "},"GitHub/07给项目增加详细的指导文档.html":{"url":"GitHub/07给项目增加详细的指导文档.html","title":"07给项目增加详细的指导文档","keywords":"","body":"给项目增加详细的指导文档 使用 GitHub 的Wiki栏，详细编辑项目指导文档： 此处可使用 markdown 编写，其次 wiki 本身就是 GitHub 的一个仓库： By Jayee            modified at 2020-02-10 13:21:37 "}}